import React, { memo, useMemo, useEffect, useRef } from 'react';
import shallow from 'zustand/shallow';
import useVisibleNodes from '../../hooks/useVisibleNodes';
import { useStore } from '../../store';
import { Position } from '../../types';
const selector = (s) => ({
    scale: s.transform[2],
    nodesDraggable: s.nodesDraggable,
    nodesConnectable: s.nodesConnectable,
    elementsSelectable: s.elementsSelectable,
    updateNodeDimensions: s.updateNodeDimensions,
    snapGrid: s.snapGrid,
    snapToGrid: s.snapToGrid,
    nodeInternals: s.nodeInternals,
});
const NodeRenderer = (props) => {
    const { scale, nodesDraggable, nodesConnectable, elementsSelectable, updateNodeDimensions, snapGrid, snapToGrid } = useStore(selector, shallow);
    const nodes = useVisibleNodes(props.onlyRenderVisibleElements);
    const resizeObserverRef = useRef();
    const resizeObserver = useMemo(() => {
        if (typeof ResizeObserver === 'undefined') {
            return null;
        }
        const observer = new ResizeObserver((entries) => {
            const updates = entries.map((entry) => ({
                id: entry.target.getAttribute('data-id'),
                nodeElement: entry.target,
                forceUpdate: true,
            }));
            updateNodeDimensions(updates);
        });
        resizeObserverRef.current = observer;
        return observer;
    }, []);
    useEffect(() => {
        return () => {
            resizeObserverRef?.current?.disconnect();
        };
    }, []);
    return (React.createElement("div", { className: "react-flow__nodes react-flow__container" }, nodes.map((node) => {
        const nodeType = node.type || 'default';
        if (!props.nodeTypes[nodeType]) {
            console.warn(`Node type "${nodeType}" not found. Using fallback type "default".`);
        }
        const NodeComponent = (props.nodeTypes[nodeType] || props.nodeTypes.default);
        const isDraggable = !!(node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'));
        const isSelectable = !!(node.selectable || (elementsSelectable && typeof node.selectable === 'undefined'));
        const isConnectable = !!(node.connectable || (nodesConnectable && typeof node.connectable === 'undefined'));
        return (React.createElement(NodeComponent, { key: node.id, id: node.id, className: node.className, style: node.style, type: nodeType, data: node.data, sourcePosition: node.sourcePosition || Position.Bottom, targetPosition: node.targetPosition || Position.Top, hidden: node.hidden, xPos: node.positionAbsolute?.x ?? 0, yPos: node.positionAbsolute?.y ?? 0, dragging: !!node.dragging, snapGrid: snapGrid, snapToGrid: snapToGrid, selectNodesOnDrag: props.selectNodesOnDrag, onClick: props.onNodeClick, onMouseEnter: props.onNodeMouseEnter, onMouseMove: props.onNodeMouseMove, onMouseLeave: props.onNodeMouseLeave, onContextMenu: props.onNodeContextMenu, onNodeDoubleClick: props.onNodeDoubleClick, onNodeDragStart: props.onNodeDragStart, onNodeDrag: props.onNodeDrag, onNodeDragStop: props.onNodeDragStop, scale: scale, selected: !!node.selected, isDraggable: isDraggable, isSelectable: isSelectable, isConnectable: isConnectable, resizeObserver: resizeObserver, dragHandle: node.dragHandle, zIndex: node.z ?? 0, isParent: !!node.isParent, noDragClassName: props.noDragClassName, noPanClassName: props.noPanClassName }));
    })));
};
NodeRenderer.displayName = 'NodeRenderer';
export default memo(NodeRenderer);
