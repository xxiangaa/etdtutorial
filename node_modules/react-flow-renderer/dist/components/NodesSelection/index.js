/**
 * The nodes selection rectangle gets displayed when a user
 * made a selection with on or several nodes
 */
import React, { memo, useMemo, useCallback, useRef } from 'react';
import { DraggableCore } from 'react-draggable';
import cc from 'classcat';
import shallow from 'zustand/shallow';
import { useStore } from '../../store';
import { getRectOfNodes } from '../../utils/graph';
// @TODO: work with nodeInternals instead of converting it to an array
const selector = (s) => ({
    transform: s.transform,
    selectedNodesBbox: s.selectedNodesBbox,
    userSelectionActive: s.userSelectionActive,
    selectedNodes: Array.from(s.nodeInternals)
        .filter(([_, n]) => n.selected)
        .map(([_, n]) => n),
    snapToGrid: s.snapToGrid,
    snapGrid: s.snapGrid,
    updateNodePosition: s.updateNodePosition,
});
function NodesSelection({ onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, noPanClassName, }) {
    const { transform, userSelectionActive, selectedNodes, snapToGrid, snapGrid, updateNodePosition } = useStore(selector, shallow);
    const [tX, tY, tScale] = transform;
    const nodeRef = useRef(null);
    const grid = useMemo(() => (snapToGrid ? snapGrid : [1, 1]), [snapToGrid, snapGrid]);
    const style = useMemo(() => ({
        transform: `translate(${tX}px,${tY}px) scale(${tScale})`,
    }), [tX, tY, tScale]);
    const selectedNodesBbox = useMemo(() => getRectOfNodes(selectedNodes), [selectedNodes]);
    const innerStyle = useMemo(() => ({
        width: selectedNodesBbox.width,
        height: selectedNodesBbox.height,
        top: selectedNodesBbox.y,
        left: selectedNodesBbox.x,
    }), [selectedNodesBbox]);
    const onStart = useCallback((event) => {
        onSelectionDragStart?.(event, selectedNodes);
    }, [onSelectionDragStart, selectedNodes]);
    const onDrag = useCallback((event, data) => {
        updateNodePosition({
            diff: {
                x: data.deltaX,
                y: data.deltaY,
            },
            dragging: true,
        });
        onSelectionDrag?.(event, selectedNodes);
    }, [onSelectionDrag, selectedNodes, updateNodePosition]);
    const onStop = useCallback((event) => {
        updateNodePosition({
            dragging: false,
        });
        onSelectionDragStop?.(event, selectedNodes);
    }, [selectedNodes, onSelectionDragStop]);
    const onContextMenu = useCallback((event) => {
        onSelectionContextMenu?.(event, selectedNodes);
    }, [onSelectionContextMenu, selectedNodes]);
    if (!selectedNodes?.length || userSelectionActive) {
        return null;
    }
    return (React.createElement("div", { className: cc(['react-flow__nodesselection', 'react-flow__container', noPanClassName]), style: style },
        React.createElement(DraggableCore, { scale: tScale, grid: grid, onStart: (event) => onStart(event), onDrag: (event, data) => onDrag(event, data), onStop: (event) => onStop(event), nodeRef: nodeRef, enableUserSelectHack: false },
            React.createElement("div", { ref: nodeRef, className: "react-flow__nodesselection-rect", onContextMenu: onContextMenu, style: innerStyle }))));
}
export default memo(NodesSelection);
