import React, { memo, useContext, useCallback, forwardRef } from 'react';
import cc from 'classcat';
import shallow from 'zustand/shallow';
import { useStore, useStoreApi } from '../../store';
import NodeIdContext from '../../contexts/NodeIdContext';
import { Position } from '../../types';
import { checkElementBelowIsValid, onMouseDown } from './handler';
import { getHostForElement } from '../../utils';
import { addEdge } from '../../utils/graph';
const alwaysValid = () => true;
const selector = (s) => ({
    onConnectAction: s.onConnect,
    onConnectStart: s.onConnectStart,
    onConnectStop: s.onConnectStop,
    onConnectEnd: s.onConnectEnd,
    connectionMode: s.connectionMode,
    connectionStartHandle: s.connectionStartHandle,
    connectOnClick: s.connectOnClick,
    hasDefaultEdges: s.hasDefaultEdges,
});
const Handle = forwardRef(({ type = 'source', position = Position.Top, isValidConnection = alwaysValid, isConnectable = true, id, onConnect, children, className, ...rest }, ref) => {
    const store = useStoreApi();
    const nodeId = useContext(NodeIdContext);
    const { onConnectAction, onConnectStart, onConnectStop, onConnectEnd, connectionMode, connectionStartHandle, connectOnClick, hasDefaultEdges, } = useStore(selector, shallow);
    const handleId = id || null;
    const isTarget = type === 'target';
    const onConnectExtended = useCallback((params) => {
        const { defaultEdgeOptions } = store.getState();
        const edgeParams = {
            ...defaultEdgeOptions,
            ...params,
        };
        if (hasDefaultEdges) {
            const { edges } = store.getState();
            store.setState({ edges: addEdge(edgeParams, edges) });
        }
        onConnectAction?.(edgeParams);
        onConnect?.(edgeParams);
    }, [hasDefaultEdges, onConnectAction, onConnect]);
    const onMouseDownHandler = useCallback((event) => {
        if (event.button === 0) {
            onMouseDown(event, handleId, nodeId, store.setState, onConnectExtended, isTarget, isValidConnection, connectionMode, undefined, undefined, onConnectStart, onConnectStop, onConnectEnd);
        }
    }, [
        handleId,
        nodeId,
        onConnectExtended,
        isTarget,
        isValidConnection,
        connectionMode,
        onConnectStart,
        onConnectStop,
        onConnectEnd,
    ]);
    const onClick = useCallback((event) => {
        if (!connectionStartHandle) {
            onConnectStart?.(event, { nodeId, handleId, handleType: type });
            store.setState({ connectionStartHandle: { nodeId, type, handleId } });
        }
        else {
            const doc = getHostForElement(event.target);
            const { connection, isValid } = checkElementBelowIsValid(event, connectionMode, connectionStartHandle.type === 'target', connectionStartHandle.nodeId, connectionStartHandle.handleId || null, isValidConnection, doc);
            onConnectStop?.(event);
            if (isValid) {
                onConnectExtended(connection);
            }
            onConnectEnd?.(event);
            store.setState({ connectionStartHandle: null });
        }
    }, [
        connectionStartHandle,
        onConnectStart,
        onConnectExtended,
        onConnectStop,
        onConnectEnd,
        isTarget,
        nodeId,
        handleId,
        type,
    ]);
    const handleClasses = cc([
        'react-flow__handle',
        `react-flow__handle-${position}`,
        'nodrag',
        className,
        {
            source: !isTarget,
            target: isTarget,
            connectable: isConnectable,
            connecting: connectionStartHandle?.nodeId === nodeId &&
                connectionStartHandle?.handleId === handleId &&
                connectionStartHandle?.type === type,
        },
    ]);
    return (React.createElement("div", { "data-handleid": handleId, "data-nodeid": nodeId, "data-handlepos": position, className: handleClasses, onMouseDown: onMouseDownHandler, onClick: connectOnClick ? onClick : undefined, ref: ref, ...rest }, children));
});
Handle.displayName = 'Handle';
export default memo(Handle);
